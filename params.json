{"name":"KrylovFRITools","tagline":"We present proof of concept code - MATLAB and Python - for identification of the union of subspaces in FRI estimation problems when the number of measurements greatly exceeds the dimension of the model.","body":"<script type=\"text/javascript\"\r\n            src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\r\n    </script>\r\n\r\n# Preamble\r\n\r\n**Abstract** --- *We present proof of concept code -- MATLAB and Python -- for\r\nidentification of the union of subspaces in FRI estimation problems when the\r\nnumber of measurements greatly exceeds the dimension of the model. This\r\nscenario happens frequently in wireless communications, *eg.* OFDM channels\r\nestimation from pilots. The key properties are a superlinear running-time and\r\na linear memory consumption in term of the input size.*\r\n\r\n\r\n## Formulation of the problem\r\n\r\nWe consider a set of  $P$ sequences of measurements\r\n\r\n\\\\[Y_p[m] = \\sum_{k=1}^K c_{k,p}e^{-jD\\omega_k m}+E[m]\\ ,\\quad\\ |m|\\leq M, \\quad p=1,\\ \\dots, \\ P,\\\\]\r\n\r\nwhere \r\n\r\n- $K$ is the number of subspaces in the union of subspaces,\r\n- $D$ is an integer decimation factor ($D= 1,\\ 2,\\ 3,\\ \\dots$),\r\n- $\\omega_k$ are unknown phases within $[-\\pi/D ,\\  \\pi/D[$,\r\n- $c_{k,p}$ are unknown complex-valued scalars,\r\n- $E$ is a sequence of white gaussian noise.\r\n\r\nTherefore, the input is of size $P(2M+1)$. The problem we consider is the fast\r\nand accurate estimation of the unknown phases $\\omega_k$ from the measurements.\r\n\r\n\r\n## Theoretical guarantees of the proposed solution\r\n\r\nThe properties of our solution can be summarized and compared with other methods as :\r\n\r\n|Algorithm| Main computation |Storage | Latency | Processing units (pu.) |\r\n|---------|------------------|--------|---------|------------------------|\r\n|Krylov   | $KPM\\log M$    | $KM$ | $KM$  | $P\\:\\times$ FFT engines ($2(M+1)$ points FFT)|\r\n|Full SVD (serial)|  $PM^{3}$ | $PM^{2}$ | $PM^{3}$ | 1 SVD multipurpose processor |\r\n|Full SVD (systolic array) | $PM^{3}$ | $PM^{2}$ | $M(\\log M +P)$ | $M^{2}\\times\\:$ 2-by-2  SVD pu. |\r\n\r\n: The full SVD is done with Jacobi rotations and can be massively parallelized\r\nusing the systolic array method [@Brent1985]. Parallelism greatly reduces the\r\nlatency of the system, but since it does not reduce the number of computations\r\nit comes at the cost of using multiple processing units. The numbers are to be\r\nunderstood in \"$\\mathcal{O}$\" notation.\r\n\r\n\r\nThe storage improvement comes from the fact that *the data matrix used within\r\nthe ESPRIT algorithm is never explicitely built*.  The computational\r\nimprovement is guaranteed by [@Barbotin2013, Theorem 2.3], where it is proven\r\nthat the sine squared of the principal angle between the signal space -- The\r\nsignal space is the union of subspaces referred above -- of dimension $K$ and\r\nits approximation found in a Krylov subspace of dimension $L>K$ evolves as\r\n\r\n$$\\mathcal O\\left(\\left(\\frac{\\log M}{\\sqrt{M}}\\right)^{2(L-K)}\\right).$$\r\n\r\n(For a small angle, the first order Taylor approximation of the sine function\r\nindicates that the principal angle is of magnitude $\\mathcal O\\left(\\left(\\frac{\\log M}{\\sqrt{M}}\\right)^{(L-K)}\\right).$)\r\n\r\nIt indicates that the approximation error decays as a power degree\r\ncorresponding to the number of additional dimensions compared to the signal\r\nsubspace, so that a low enough numerical error is met for $L\\sim\\mathcal O(K)$\r\nand $M$ large enough.\r\n\r\n# Code snippets\r\n\r\n## Foreword\r\nKeep in mind that:\r\n\r\n- We provide a MATLAB and a Python code The Python code implements only the single input case, *ie.* $P=1$.\r\n- Since the measurements are indexed by $|m|\\leq M$ it assumes that they are in an odd number. This is not a requirement *per se*, and the code can easily be tweaked to deal with it. \r\n- Both codes output  the phasor $z_k=e^{jD\\omega_k}$. The original phase is retrieved without ambiguity by a simple division of the phase by $D$ assuming it belongs to $[-\\pi/D ,\\  \\pi/D[$.\r\n- This is a basic code, it does not include the estimation of the signal space dimension nor the estimation of the coefficients $c_{k,p}$ -- the later is quite straightforward and can be done efficiently using rational interpolation [@Pan2001].\r\n\r\n## MATLAB code\r\n\r\nFirst, we provide a simple implementation of the ESPRIT algorithm using a *least-squares* (LS) or *total least-squares* (TLS) error metric and using either (see the Table above) : \r\n\r\n1. The \"Full SVD (serial)\" method.\r\n2. The \"Krylov\" method.\r\n\r\nSee [@Roy1989] for the original ESPRIT algorithm, and [@Barbotin2013, Chapter 2] for more details on this particular usage.\r\n  \r\n```matlab\r\nfunction z=ESPRIT(Y,K,krylov,TLS)\r\n\r\n% INPUT\r\n%\tY :\t\t\t\tA Px(2*M+1) array of measurements (see measurement model above)\r\n%\tK :\t\t\t\tThe dimension of the signal space\r\n%\tkrylov, TLS :\tBoolean flags enabling/disabling the use of the Krylov method and TLS\r\n%\r\n% OUTPUT\r\n%\tz :\t\t\t\tA vector containing the phasors exp(D*omega)\r\n\r\n  if krylov\r\n      [V D]=sigspace_toeplitz_Krylov(Y,K);\r\n  else\r\n      [V D]=sigspace_toeplitz(Y,K);\r\n  end\r\n\r\n  if TLS\r\n      %ESPRIT-TLS\r\n      [~,~,C]=svd([V(1:(end-1),1:K) V(2:end,1:K)],0);\r\n      Phi=eig(-C(1:K,(K+1):(2*K))/C((K+1):(2*K),(K+1):(2*K)));%literally: eig(Psi)\r\n  else\r\n      %ESPRIT-LS\r\n      Phi=eig(V(1:(end-1),1:K)\\V(2:end,1:K));\r\n  end\r\n  z=Phi(:);\r\nend\r\n```\r\n\r\nThe two functions ``sigspace_toeplitz_Krylov`` and ``sigspace_toeplitz`` are yet to be defined.\r\n\r\nFirst the Krylov based method. Some parameters like the tolerance, the number\r\nof lanczos vectors, ... are usually fixed and therefore hard-coded -- see the\r\nstructure ``opts``. Change them to suit your needs.\r\n\r\n```matlab\r\nfunction [V D termsig]=sigspace_toeplitz_Krylov(Y,K,v0)\r\n% INPUT\r\n%\tY :\t\t\tA Px(2*M+1) array of measurements (see measurement model above)\r\n%\tK :\t\t\tThe dimension of the signal space\r\n%\tv0 :\t\t(optional) The initial vector for Lanczos algorithm\r\n%\r\n% OUTPUT\r\n%\tV :\t\t\tAn orthonormal basis of the signal space\r\n%\tD :\t\t\tThe modulus of the associated singular values\r\n%\ttermsig :\tThe termination signal of the Krylov decomposition (see the MATLAB documentation of EIGS)\r\n\r\n    [P N]=size(Y);\r\n    M=floor(N/2);\r\n    tc=Y(:,(N-M):end).'; %dim = MxP\r\n    tl=Y(:,(N-M):-1:1).';  %dim = MxP\r\n    sn=mod(N,2);\r\n    \r\n    %% FFT implementation of T'*T*f (T is  stack-toeplitz)\r\n    %tc contains the leading column of each toeplitz block (P columns)\r\n    %tr contains the leading row of each toeplitz block (P rows)\r\n    fc=fft([tc;zeros(1,P);tl(end:-1:2,:)]);\r\n    fcconj=fft([conj(tl);zeros(1,P);conj(tc(end:-1:2,:))]);\r\n    function g=mmult(f)\r\n        g=[f; zeros(M+sn,1)];\r\n        g=ifft(bsxfun(@times,fc,fft(g)));\r\n        g((M+2):end,:,:)=0;\r\n        g=ifft(bsxfun(@times,fcconj,fft(g)));\r\n        g=sum(g(1:(M+1),:),2);\r\n    end\r\n    \r\n    %% Arguments for eigs()\r\n    A=@(f)mmult(f); %pointer to the mat-vec multiply\r\n    if nargin>2\r\n        opts.v0=v0; %initial vector of lanczos, set for tracking\r\n    end\r\n    opts.tol=1e-6;  %play with it\r\n    opts.issym=1;   %We have an hermitian square matrix\r\n    opts.isreal=0;  %may apply if Y is real\r\n    opts.p=max(2*K+1,5);     %# of lanczos vectors\r\n    \r\n    [V D termsig]=eigs(A,M+1,K,'lm',opts);\r\n    D=sqrt(diag(D));\r\nend\r\n```\r\n\r\nDuring the Krylov subspace projection the block-Toeplitz data matrix $\\mathbf\r\nT$ is only accessed through matrix vector multiplications, therefore it does\r\nnot have to be built explicitely, rather we coded the function ``mmult`` which\r\nuses the FFT to perform the matrix-vector multiplication.\r\n\r\nAs a comparison, the direct implementation  ``sigspace_toeplitz`` would be:\r\n\r\n```matlab\r\nfunction [V D]=sigspace_toeplitz(Y,K)\r\n% INPUT\r\n%\tY :\t\t\tA Px(2*M+1) array of measurements (see measurement model above)\r\n%\tK :\t\t\tThe dimension of the signal space\r\n%\r\n% OUTPUT\r\n%\tV :\t\t\tAn orthonormal basis of the signal space\r\n%\tD :\t\t\tThe modulus of the associated singular values\r\n    N=size(Y,2);\r\n    L=floor(N/2);\r\n    T=blockToeplitz(Y,L);\r\n    [~,D,V]=svd(T,0);\r\n    D=diag(D);\r\n    V=V(:,1:K);\r\n    D=D(1:K);\r\nend\r\n\r\nfunction T=blockToeplitz(Y,L)\r\n    [P N]=size(Y);\r\n    M=N-L+1;\r\n    T=zeros(P*M,L);\r\n    for b=1:P\r\n        T(M*(b-1)+(1:M),:)=toeplitz(Y(b,L:end),Y(b,L:-1:1));\r\n    end\r\nend\r\n\r\n```\r\n\r\n## Python code\r\n\r\nBelow is a simple Python class for a single input ($P=1$). Extension to multiple inputs is relatively easy, follow the MATLAB code.\r\n\r\n```python\r\n# This class stores a Toeplitz matrix implicitly (generator) and provide fast methods to evaluate its column-space\r\n# and the roots of its generator\r\nimport numpy as np\r\nfrom scipy.sparse.linalg import LinearOperator, eigs\r\nimport scipy.fftpack as fftp\r\nfrom scipy.linalg import svd, eig, lstsq\r\nclass toeplitzgen:\r\n\tdef __init__(self, col,row):\r\n\t\tself.col=np.asarray(col).reshape((-1))\r\n\t\tself.row=np.asarray(row).reshape((-1))\r\n\t\tself.M=self.row.size\r\n\t\tassert self.M==self.col.size\r\n\t\tassert self.row[0]==self.col[0]\r\n\r\n\t\tself.fc=fftp.fft(np.concatenate((self.col,np.zeros(1),self.row[-1:0:-1])))\r\n\t\tself.fcconj=fftp.fft(np.concatenate((np.conj(self.row),np.zeros(1),np.conj(self.col[-1:0:-1]))))\r\n\t\tself.linop=LinearOperator((self.M,self.M),matvec=self.vmult,rmatvec=self.vmult,matmat=self.mmult)\r\n\t\tself.TOL=1e-10\r\n\r\n\tdef vmult(self,x):\r\n\t\tg=fftp.ifft(self.fc*fftp.fft(np.concatenate((x.reshape((-1)),np.zeros((self.M))))))\r\n\t\tg[self.M:]=0;\r\n\t\treturn fftp.ifft(self.fcconj*fftp.fft(g))[0:self.M]\r\n\r\n\tdef mmult(self,A):\r\n\t\tP=A.shape[1]\r\n\t\tG=fftp.ifft(self.fc.reshape((-1,1))*fftp.fft(np.concatenate((A,np.zeros((self.M,P)))),None,0),None,0)\r\n\t\tG[self.M:][:]=0;\r\n\t\treturn fftp.ifft(self.fcconj.reshape((-1,1))*fftp.fft(G,None,0),None,0)[0:self.M,:]\r\n\r\n\tdef colSpace(self,K):\r\n\t\tevl, evct = eigs(self.linop,K,tol=self.TOL)\r\n\t\treturn evct\r\n\r\n\tdef ESPRIT_TLS(self,K):\r\n\t\tV0=eigs(self.linop,K,tol=self.TOL)[1]\r\n\t\tC=svd(np.concatenate((V0[0:-1,:],V0[1:,:]),1),False)[2].T\r\n\t\treturn -\r\n```\r\n\r\nFor more details, see the [documentation on the ``LinearOperator`` object](http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator).\r\n\r\nAs a quick check, the fast implementation quickly outperforms the direct implementation as $M$ grows :\r\n\r\n![Median runtime of ESPRIT-TLS ($K = 5$, $P = 1$) on a single channel for a given number of pilots $2M + 1$. The test is coded in Python and uses the LAPACK library to compute SVDs and the ARPACK library for the Lanczos iterations. The fast matrix-vector multiplication uses the FFTW3 library.](./benchmark.png \"benchmark\")\r\n\r\n# Bibliography\r\n\r\nBarbotin, Yann. 2013. “Parametric Estimation of Sparse Channels: Theory and \r\nApplications.” PhD thesis, EPFL – School of Information; Communications.\r\n\r\nBrent, RP, FT Luk, and C. Van Loan. 1985. “Computation of the Singular Value\r\nDecomposition Using Mesh-connected Processors.” *Journal of VLSI and Computer\r\nSystems* 1 (3): 242–270.\r\n\r\nPan, Victor. 2001. *Structured Matrices and Polynomials: Unified Superfast\r\nAlgorithms*. Springer Verlag.\r\n\r\nRoy, R., and T. Kailath. 1989. “ESPRIT-Estimation of Signal Parameters Via \r\nRotational Invariance Techniques.” *IEEE Trans. Acoust., Speech, Signal\r\nProcess.* 37: 984–995.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}